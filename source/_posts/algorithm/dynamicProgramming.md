---
title: dynamicProgramming
date: 2020-06-22 14:53:00
tags: 算法
categories:
    - [算法]
---

# 动态规划

大家做算法都遇到一些动态规划的问题，从一开始不知如何入手到理解动态规划，找到每个状态之间的联系，这里记录一下自己对动态规划的理解和新的。

## 什么是动态规划

维基百科上对动态规划的描述是：动态规划在查找有很多重叠子问题的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。因此，动态规划保存递归时的结果，因而不会在解决同样的问题时花费时间。

上面的话术较为官方，我们直接参照动态规划的适用情况就能比较深刻的对其了解。

1. 最优子结构性质：如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态規劃算法解决问题提供了重要线索。
2. 无后效性：即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。
子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态規劃算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率，降低了时间复杂度。
3. 动态规划算法通常基于一个递推公式及一个或多个初始状态。当前子问题的解将由上一次子问题的解推出。使用动态规划来解题只需要多项式时间复杂度，因此它比回溯法、暴力法等要快许多。

这里使用一个爬楼梯的例子，一个人每次最多可以爬两个台阶，每个都台阶都有需要花费的体力cost[i];给定一个楼梯cost数组，求爬完所需要的最小体力。

这个问题毫无疑问是一个最优解问题，我们可以将其拆解成一个子问题，爬到第i个台阶所要的最小代价。我们将其计为dp[i]，一个人最多每次两个台阶，也就是到第i层所耗费的最小体力只和到第i-1和第i-2层所需要的最小体力有关系。其实到这里我们已经可以简单的列出一个简单关系：
dp[i] = Math.min(dp[i-1], d[i-2]) + cost[i];

不过我们还是从0开始，以当前状态最优解找出下一个状态的最优解

到第一层的最小代价： dp[0] = cost[0]

到第二层的最小代价： dp[1] = cost[1];

由第三层开始最小代价就是看起前两层哪个代价小采用哪个方案，然后踩到当前层即可。

到第三层的最小代价：dp[2] = Math.min(dp[0], dp[1]) + cost(2);

到第i层的最小代价：dp[i] = Math.min(dp[i - 1], dp[i -2]) + cost(i);
到了这里我们应该能写出我们的函数了

``` javascript
var minCostClimbingStairs = function(cost) {
    const length = cost.length;
    const dp = [cost[0], cost[1]];
    for (let i = 2; i < length ; i++ ) {
        dp[i] = cost[i] + Math.min(dp[i - 1] , dp[i-2]);
    }
    return Math.min(dp[length-1],dp[length -2] );
};
```

看看这个例子我们做了什么?

1. 将一个最优解问题拆分为一个子问题: 到第i层需要耗费的最小体力，将其存为dp[i]。
2. 我们可以判断出当dp[i]于到达前面两层的台阶有关系，于是我们希望获取其状态转移方程。如果可以我们直接列出。否则到第三部。
3. 我们从列出从第1层到第i层的每个状态下其最优解dp值，从而找到下一个状态下的最优解规律。

我们再回头看看动态规划特性：

1. 最优子结构性质，也就是其子问题的拆分。无后效性：
2. 当前解只基于之前状态下的最优解，跟其后更大问题无关。
3. 动态规划算法通常基于一个递推公式及一个或多个初始状态。当前子问题的解将由上一次子问题的解推出。

本文简单的介绍了一下动态规划的特点和其适用特性。希望对大家有所帮助和理解，大家可以结合这些特性来判断是否适合动态规划来解题，dp问题的最难点其实就是分析出当前状态基于之前状态的状态转移方程。