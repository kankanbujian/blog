1. 函数的几个属性
    * length: 表示函数的预期传入的参数个数，如果指定了默认参数，则表示没有指定默认参数的个数
    * name: 函数的名字, 若将具名函数赋予变量，则名字为具名函数而不是变量名
    * arguments: 类数组对象，函数调用时的一些信息，数组存放着函数调用传入的入参，callee属性，指向该函数，匿名函数可以通过arguments.callee调用自身
1. 什么是函数声明？
    * function在语句的行首
    * 格式为function fnName() {}， 也就是函数声明必须是具名函数！
    * 函数声明存在变量提升，在预编译期间会先读取，保证在代码执行前可用
    

2. 函数表达式
    * 函数表达式中的具名函数只能在函数体内用，其本质是在函数表达式执行的环境变量内创建了一个Const变量（也就是该表达式的函数名），并且将表达式的函数赋给这个Const变量，因此该函数名名只在该函数内部有效，并且此绑定是常量绑定，无法进行赋值。
    * 函数表达式可以立即执行
3. 立即执行函数
    * 立即执行函数中的函数都是一个函数表达式
    
4. 对于new干了哪些事情
本质上就是说构造函数创建一个实例究竟做了哪些操作
```js
    function A() {}

    var a = new A(...rest)
    // 1. 创建一个A的实例对象
    let obj = new Object()
    // 2. A中的this绑定到对象上，并且执行构造函数A中的代码
    var obj2 = A.apply(obj, rest)
    // 若构造函数本身就有对象返回，则返回的即为实例否则用创建好的
    let instance = typeof obje2 === 'object' ? obj2 : obj
    // 完善当前实例的原型链
    instance.__proto__ = A.prototype
    // 返回实例
    return instance

    // 函数内部有一个[[Contruct]]属性, new 会通过该[[Construct]]->Cstruct
    const o = Object.create(A.prototype)
    const ret = Cstruct.apply(o, rest)
    
    return ret || o
```
5. 箭头函数
    * 箭头函数没有this，其this跟当前箭头函数所定义的词法作用域的this保持一致
    * 不能使用new，没有[[Constructor]]属性，new调用的时候需要调用对象内部的[[Contructor]]，自然无法调用，同时箭头函数没有自己的this作为环境上下文对象，自然无法通过call, apply, bind将构造函数的环境变量改成实例对象返回，
    * 没有arguments，无法调用自身
    * 不能用yield，无法不能作为generator函数


原型：
    实例无法通过原型链修改原型链上的值，而是会进行属性遮蔽，将该值赋值到该实例上
```
    
```