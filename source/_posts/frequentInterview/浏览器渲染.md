
# 浏览器渲染


## 开始时机
当网络线程获取到html资源后，会包装一个渲染html任务，放到消息队列中，等待渲染主线程执行完当前任务后，根据事件循环去消息队列中获取到渲染html任务，开始渲染。


## 1、html解析-parse
主要工作其实很简单，如何从后端获取到的html字符串如何根据浏览器需要去解析出文档节点的结构（也就是文档对象模型DOM），如何解析出节点的具体样式结构（也就是cssom），遇到js如何运行。

### html解析
html解析时会开启一个预解析线程，该线程会率先下载外部css和js文件。主线程碰到css则去解析css，遇到js则执行js。当主线程碰到link，若css文件还没下完，主线程也不会等待，而是继续解析后续html。

### js解析
遇到js直接等待执行，并且当前script外部脚本没有下载完成则会等待下载执行完才会后续html解析，因为script中可能会改变当前dom树的结构，所以需要等待。（当然这里是不考虑async和defer属性的情况）

### dom树构建
简单来说将html一个个字符串转换成文档对象模型，也就是由拥有页面信息结构的对象构造的树形结构，从而可以让我们通过简单的操作dom对象从而去改变对应页面的信息渲染。

## cssom  ----css object modal
同dom一样，生成一个样式规则树StylSheetList。这里如何遇到外部css文件，会提前进行下载，具体是解析html时会开启一个预解析线程，他会快速查看整个html，如果发现css则立即用网络线程去下载解析，并且主线程遇到对应的link等外部样式不会终止而是跳过，

## 2. 样式计算-computed style  get render Tree
主线程由根节点遍历整个dom树，依次依靠cssom，计算出每个节点的最终样式，成为computed style，这一过程中，完成之后则会得到一个有样式的dom树render tree

## 3、布局-layout 
现在已经得到了一个有样式的dom树了，现在就需要根据每个样式去计算出每个节点的几何信息，比如宽高、相对包含块的位置等，最终会生成layout树 

## 4、分层-layer
主线程有一套逻辑对当前的布局树进行分层，这样每个层改变后只会对当前层进行处理，而不用对整个布局树处理。
滚动条、堆叠上下文、transform、opacity等或多或少都会对分层产生影响

## 5、绘制-paint
为每一层生成绘制指令

--- 
  
## 合成线程
在合成线程上，会对每个图层进行分块，划分为更小的区域单元，然后使用多线程并发同时对每个区块进行处理，加快整个界面的渲染

## 6、分块
会对每个图层进行分块，划分为更小的区域单元，然后使用多线程并发同时对每个区块进行处理，加快整个界面的渲染

## 7、光栅化
将每一个分块变成一个个位图，位图是每个元素  

## 8、 draw
合成线程计算出每个位图在屏幕的位置，生成一个个（quad指引）信息，指引信息会标识每个位图具体画到屏幕哪个位置，以及考虑旋转、缩放等变形。 

<u>**tip 变形发生在合成线程，与渲染主线程无关，这也是transfrom效率高的本质原因，他不会被js阻塞，因为js运行在渲染主线程**</u>

最终由合成线程携带着具体每个像素的绘制信息提交给GPU进程，完成屏幕成像。



文本内容必须放在行盒元素里
行盒和块盒不能相邻

属性计算过程：
- 层叠
- 继承 

视觉格式化模型：
- 盒模型
- 包含块


# 常见问题
## 什么是reflow，回流

节点的布局或者几何信息发生变化就叫回流，意味着该节点附近连带的所有节点的布局都可能发生变化所以都会引起回流，并且布局变化就需要重新生成布局树，从layout开始所有的后续渲染都得走一遍，非常损耗性能 （结构、宽高、位置）。因此为了优化，浏览器会对布局操作进行统一的优化处理。

比如当前通过js会对布局发生一系列变化，这里不会每js语句对布局的变化都直接去进行回流处理，而是包装一个回流任务放到对应的消息队列中，当主线程该部分js都执行完后，再统一执行回流任务。  

但是为了在在修改后能立即读取到修改后的几何信息，所以当js中有获取布局信息的操作时，会将去除回流优化，同步reflow，所以设置会异步reflow，读取信息会同步执行reflow，这是为了保证信息的一致性，因此可以通过这种方式进行强制的回流渲染。

## 什么是repaint-重绘 

顾名思义，就是需要重新进行paint处理
本质其实就是重新根据分层信息计算绘制指令
当改变了可见样式后，就会需要重新计算，引发repaint
布局等几何信息肯定是可见样式，所以回流一定引起重绘

## 优化方式

## css3 硬件加速，css3硬件加速是通过合成线程进行分块、光栅化，最终提交到GPU进行加速处理等，所以主线程的阻塞不会对其造成影响
因此
    transform
    opacity
    filters
    Will-change
只会影响最后draw等阶段，该阶段位于合成线程上，不会影响渲染主线程，也不会被主线程所阻塞






